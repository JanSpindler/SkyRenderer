#version 450
#extension GL_EXT_debug_printf : enable

#include "scattering.h"
#include "multi_scattering.h"
#include "gathering.h"
#include "env_set.h"

layout (set = MS_SETS_GATHERING_SAMPLER, binding = 0) uniform sampler2D gathering_tex;
layout (set = MS_SETS_SUM_IMAGE, binding = 0, rgba16f) uniform image3D sum_image;
layout (set = MS_SETS_SCATTERING_IMAGE, binding = 0, rgba16f) uniform writeonly image3D scattering_image;
ENV_SET(MS_SETS_ENV, env)
layout (push_constant) uniform push_constants {
	uint offset;
} pc;

#include "functions.glsl"

vec4 fetch_gathering(vec2 p, float c_sun) {
	return texture(gathering_tex, tex_address_shifted(
		vec2(height_to_tex(height(p, env.r_planet), env.atmosphere_height), sun_to_tex(c_sun)),
		vec2(GATHERING_RESOLUTION_HEIGHT, GATHERING_RESOLUTION_SUN)));
}

// @param view is normalized, points away from cam.
// @param light_in is normalized, points away from light source.
//
// @return vec4, rgb are rayleigh, mie can be approximated.
vec4 multi_scattering(float h,
	vec2 view,
	vec2 light_in,
	float r_scale_height,
	float m_scale_height,
	vec3 scoeff_r,
	vec3 scoeff_m,
	vec3 extcoeff_r,
	vec3 extcoeff_m,
	float rad_e,
	float rad_a) {

	// pos is height from earth-center.
	// (assume h is height from earth-surface);
	vec2 pa = vec2(0, h+rad_e);
	// intersection with earth or atmosphere.
	vec2 pb = atmosphere_earth_intersect(pa, view, rad_e, rad_a);
	// if (abs(length(pb) - RAD_E) < 1)
	// 	debugPrintfEXT("%f", length(pb));
	if (pb.x == INFINITY) {
		// no intersection with atmosphere.
		return vec4(0,0,0,0);
	}

	// dot with (0,1).
	float c_sun = -light_in.y;

	// calculate inscattering at pa (for prev_insc_*):
	vec4 insc_prev = fetch_gathering(pa, c_sun);

	vec4 insc_sum = vec4(0,0,0,0);
	int step_count = int(length(pa - pb)/SCATTERING_STEP_LENGTH);
	vec2 p = pa;
	for (int i = 1; i <= step_count; ++i) {
		p = pa + i*SCATTERING_STEP_LENGTH*view;

		vec3 tpap = transmittance(pa, p, r_scale_height, m_scale_height, extcoeff_r, extcoeff_m, rad_e);
		// use r for mie only.
		vec4 gathered_p = fetch_gathering(p, c_sun);
		vec4 insc = vec4(gathered_p.rgb*density_r(height(p, rad_e), r_scale_height), density_m(height(p, rad_e), m_scale_height).r*gathered_p.a)*vec4(tpap, tpap.r);

		insc_sum += (insc_prev + insc)/2.0f*SCATTERING_STEP_LENGTH;

		insc_prev = insc;
	}
	vec3 tpapb = transmittance(pa, pb, r_scale_height, m_scale_height, scoeff_r, scoeff_m, rad_e);
	// use r for mie only.
	vec4 gathered_p = fetch_gathering(pb, c_sun);
	vec4 insc = vec4(gathered_p.rgb*density_r(height(pb, rad_e), r_scale_height), density_m(height(pb, rad_e), m_scale_height).r*gathered_p.a)*vec4(tpapb, tpapb.r);

	// distance from last p in loop.
	insc_sum += (insc_prev + insc)/2.0f*length(pb-p);

	return vec4(insc_sum.rgb*scoeff_r, insc_sum.a*scoeff_m.r)/(4.0f*pi);
}

void main() {
	// +0.01 to prevent stupid edgecases.
	float tex_height = float(pc.offset + gl_WorkGroupID.x)/SCATTERING_RESOLUTION_HEIGHT+0.01;
	float tex_view = float(gl_WorkGroupID.y)/SCATTERING_RESOLUTION_VIEW;
	float tex_sun = float(gl_WorkGroupID.z)/SCATTERING_RESOLUTION_SUN;

	float actual_height = tex_to_height(tex_height, env.atmosphere_height);
	float c_view = tex_to_view(tex_view, actual_height, env.r_planet);
	float c_sun = tex_to_sun(tex_sun);

	vec4 r_rgb_m_r = multi_scattering(
		actual_height,
		unit_vec_from_cos(c_view),
		-unit_vec_from_cos(c_sun),
		env.rayleigh_scale_height,
		env.mie_scale_height,
		env.rayleigh_scattering_coefficient,
		env.mie_scattering_coefficient,
		env.rayleigh_scattering_coefficient,
		env.mie_scattering_coefficient/0.9f,
		env.r_planet,
		env.r_atmosphere);

	ivec3 tex_coord = ivec3(gl_WorkGroupID) + ivec3(pc.offset, 0, 0);
	imageStore(scattering_image, tex_coord, r_rgb_m_r);
	imageStore(sum_image, tex_coord, r_rgb_m_r + imageLoad(sum_image, tex_coord));
}
